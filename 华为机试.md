# 华为机试

5.18机试

<img src="C:\Users\Carrie_Lee\Desktop\选调生\微信图片_20220519113920.jpg" alt="微信图片_20220519113920" style="zoom:25%;" />

~~~java
14
1 2
1 3
1 4
1 12
2 2
2 3
3 6
3 7
3 8
3 9
4 10
4 2
3 2
4 13

2
1 2
1 3


package HuaWei;

import java.util.*;

class Test1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();

        ArrayList<ArrayList<Integer>> list = new ArrayList<>();
        HashMap<Integer, ArrayList<ArrayList<Integer>>> map = new HashMap<>();
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            int style = scanner.nextInt();
            int num = scanner.nextInt();
            list.add(new ArrayList<>(Arrays.asList(num, style)));
        }

        list.sort(new Comparator<ArrayList<Integer>>() {
            @Override
            public int compare(ArrayList<Integer> o1, ArrayList<Integer> o2) {
                //如果第一列相同，那么按第二列正序
                if (o1.get(0).equals(o2.get(0))) return o1.get(1) - o2.get(1);
                //否则按照第一列排
                return o1.get(0) - o2.get(0);
            }
        });
        for (int i = 0; i < n; i++) {
            int key = list.get(i).get(0);
            ArrayList<ArrayList<Integer>> mapList = map.get(key);
            if (mapList == null) {
                mapList = new ArrayList<>();
                map.put(key, mapList);
            }
            mapList.add(new ArrayList<>(Arrays.asList(key, list.get(i).get(1))));
        }
        Iterator<Integer> iterator = map.keySet().iterator();
        while (iterator.hasNext()) {
            int num = iterator.next();
            ArrayList<ArrayList<Integer>> valueLists = map.get(num);

            if (valueLists.size() == 4) {
                for (ArrayList<Integer> valueList : valueLists) {
                    System.out.println("count==4 " + valueList);
                    res.add(valueList);
                    list.remove(valueList);
                }
            } else if (valueLists.size() == 3) {
                for (ArrayList<Integer> valueList : valueLists) {
                    System.out.println("count==3 " + valueList);
                    res.add(valueList);
                    list.remove(valueList);
                }
            } else if (valueLists.size() == 2) {
                for (ArrayList<Integer> valueList : valueLists) {
                    System.out.println("count==2 " + valueList);
                    res.add(valueList);
                    list.remove(valueList);
                }
            } else {
                for (ArrayList<Integer> restSubList : list) {
                    System.out.println("shengyu " + restSubList);
                    res.add(restSubList);
                }
                break;
            }
        }
        for (int i = 0; i < n; i++) {
            System.out.println(res.get(i).get(1) + " " + res.get(i).get(0));
        }
    }
}
~~~





<img src="C:\Users\Carrie_Lee\Desktop\选调生\微信图片_20220519113913.jpg" alt="微信图片_20220519113913" style="zoom:25%;" />



<img src="C:\Users\Carrie_Lee\Desktop\选调生\微信图片_20220519113859.jpg" alt="微信图片_20220519113859" style="zoom:25%;" />

**HJ51** **输出单向链表中倒数第k个结点**

~~~
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        while (scan.hasNext()) {
            int num = scan.nextInt();
            ListNode header = new ListNode();
            for (int i=0; i< num;i++) {
                int value = scan.nextInt();
                ListNode node = new ListNode(value, header.next);
                header.next = node;
            }
            int target = scan.nextInt();
            for (int i=0; i<target; i++) {
                header = header.next;
            }
            System.out.println(header.value);
        }
        
    }
}

class ListNode{
    int value;
    ListNode next;
    //构造器
    public ListNode(){
        
    }
    public ListNode(int value, ListNode next){
        this.value = value;
        this.next = next;
    }
}
~~~

**HJ48** **从单向链表中删除指定值的节点**

~~~java
import java.util.*;
public class Main {
    public static void main(String args[]) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            int num = scanner.nextInt();
            LinkedList<Integer> list = new LinkedList<>();
            int h = scanner.nextInt();
            list.add(h);
            for (int i = 0; i < num - 1; i++) {
                int next = scanner.nextInt();
                int cur = scanner.nextInt();
                int idx = list.indexOf(cur);
                list.add(idx + 1, next);
            }
            //必须是obj类型
            Object last = scanner.nextInt();
            list.remove(last);

            for (int val : list) {
                System.out.print(val + " ");
            }
        }
    }
}
~~~

字节的排列方式有两个通用规则:

- 大端序（Big-Endian）将数据的低位字节存放在内存的高位地址，高位字节存放在低位地址。这种排列方式与数据用字节表示时的书写顺序一致，符合人类的阅读习惯。
- 小端序（Little-Endian），将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称**小端序**。小端序与人类的阅读习惯相反，但更符合计算机读取内存的方式，因为CPU读取内存中的数据时，是从低地址向高地址方向进行读取的。

上面的文字描述有点抽象，我们拿一个例子来解释一下字节排列时的大端序和小端序。

在内存中存放整型数值`168496141` 需要4个字节，这个数值的对应的16进制表示是`0X0A0B0C0D`，这个数值在用大端序和小端序排列时的在内存中的示意图如下：

![img](https://ask.qcloudimg.com/http-save/yehe-3014091/lbwp9hbphi.jpeg?imageView2/2/w/1620)

